name: "构建MarkVision应用"

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

# 添加权限配置
permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: 设置Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 16
          cache: 'npm'

      - name: 自动更新版本号
        id: version
        run: |
          # 获取最新的tag版本号
          $latestTag = git describe --tags --abbrev=0 2>$null
          
          # 如果没有tag，使用v0.0.0作为基础版本
          if (-not $latestTag) {
            $latestTag = "v0.0.0"
          }
          
          # 去掉v前缀
          $currentVersion = $latestTag -replace "^v", ""
          
          # 拆分版本号
          $versionParts = $currentVersion.Split('.')
          $major = [int]$versionParts[0]
          $minor = [int]$versionParts[1]
          $patch = [int]$versionParts[2]
          
          # 递增补丁版本号
          $patch++
          
          # 组合新版本号
          $newVersion = "$major.$minor.$patch"
          
          # 更新package.json (指定 UTF8 编码，添加错误处理)
          try {
              $packageJsonPath = "./package.json"
              # 检查文件是否存在
              if (-not (Test-Path $packageJsonPath)) {
                  Write-Error "File not found: $packageJsonPath"
                  exit 1
              }
              $packageJsonContent = Get-Content -Path $packageJsonPath -Raw -Encoding UTF8
              $packageJson = $packageJsonContent | ConvertFrom-Json -ErrorAction Stop # 确保解析错误时停止
              $packageJson.version = $newVersion
              $packageJson | ConvertTo-Json -Depth 100 | Out-File -FilePath $packageJsonPath -Encoding UTF8
              Write-Host "Successfully updated package.json"
          } catch {
              Write-Error "Failed to update package.json: $($_.Exception.Message)"
              # 输出原始文件内容以便调试
              Write-Error "Original package.json content: $packageJsonContent"
              exit 1 # Exit immediately on error
          }
          
          # 更新tauri.conf.json (指定 UTF8 编码，添加错误处理)
          try {
              $tauriConfPath = "./src-tauri/tauri.conf.json"
              # 检查文件是否存在
              if (-not (Test-Path $tauriConfPath)) {
                  Write-Error "File not found: $tauriConfPath"
                  exit 1
              }
              $tauriConfContent = Get-Content -Path $tauriConfPath -Raw -Encoding UTF8
              $tauriConf = $tauriConfContent | ConvertFrom-Json -ErrorAction Stop # 确保解析错误时停止
              $tauriConf.package.version = $newVersion
              $tauriConf | ConvertTo-Json -Depth 100 | Out-File -FilePath $tauriConfPath -Encoding UTF8
              Write-Host "Successfully updated tauri.conf.json"
          } catch {
              Write-Error "Failed to update tauri.conf.json: $($_.Exception.Message)"
              # 输出原始文件内容以便调试
              Write-Error "Original tauri.conf.json content: $tauriConfContent"
              exit 1 # Exit immediately on error
          }
          
          # 输出新版本号供后续步骤使用
          echo "NEW_VERSION=$newVersion" >> $env:GITHUB_OUTPUT
          echo "新版本号: v$newVersion"
          # 确保脚本以成功代码结束
          exit 0
        shell: pwsh
          
      - name: 安装Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          
      - name: 安装依赖 (使用 npm ci)
        run: npm ci
        
      - name: 构建前端
        run: npm run build
        
      # 添加调试步骤 (使用 pwsh)
      - name: 检查Tauri配置和目录结构
        run: |
          echo "--- Tauri Config ---"
          Get-Content -Path src-tauri/tauri.conf.json -Encoding UTF8
          echo "`n--- src-tauri Directory ---"
          Get-ChildItem -Path src-tauri -Recurse | Select-Object FullName
        shell: pwsh
      
      - name: 构建并发布Tauri应用
        id: tauri_build
        uses: tauri-apps/tauri-action@v0.5.20
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: v${{ steps.version.outputs.NEW_VERSION }}
          releaseName: "MarkVision v${{ steps.version.outputs.NEW_VERSION }}"
          releaseBody: "MarkVision 发布版本，包含可执行文件。"
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: true
          includeRelease: true
          includeDebug: false
          tauriScript: "npm run tauri"
          args: --verbose --target x86_64-pc-windows-msvc

      # 创建便携式版本
      - name: 创建便携式版本
        run: |
          # 设置版本变量和目标目录
          $version = "${{ steps.version.outputs.NEW_VERSION }}"
          if (-not $version) { $version = "1.0.0" }  # 默认版本号，以防提取失败
          
          $appName = "MarkVision"
          $portableDir = "portable-$appName-v$version"
          
          # 查找执行文件的多个可能路径 (基于Tauri默认输出位置)
          $possiblePaths = @(
            "src-tauri\target\release\$appName.exe",
            "src-tauri\target\x86_64-pc-windows-msvc\release\$appName.exe",
            "src-tauri\target\release\bundle\$appName.exe",
            "src-tauri\target\x86_64-pc-windows-msvc\release\bundle\$appName.exe",
            "src-tauri\target\release\bundle\nsis\$appName*.exe",
            "src-tauri\target\x86_64-pc-windows-msvc\release\bundle\nsis\$appName*.exe"
          )
          
          # 列出所有可能的路径以便调试
          Write-Host "查找可执行文件的可能路径："
          foreach ($path in $possiblePaths) {
            Write-Host " - $path"
          }
          
          # 搜索所有可能的执行文件
          Write-Host "在target目录中搜索所有可执行文件："
          $allExeFiles = Get-ChildItem -Path "src-tauri\target" -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName
          foreach ($file in $allExeFiles) {
            Write-Host " - 找到: $file"
          }
          
          # 尝试从搜索结果中找到主程序
          $exePath = $null
          # 首先检查特定路径
          foreach ($path in $possiblePaths) {
            $resolvedPath = Resolve-Path -Path $path -ErrorAction SilentlyContinue
            if ($resolvedPath) {
              $exePath = $resolvedPath.Path
              Write-Host "找到可执行文件(精确路径): $exePath"
              break
            }
          }
          
          # 如果没找到，尝试通过文件名模式匹配
          if (-not $exePath -and $allExeFiles) {
            # 优先选择不在nsis目录下的MarkVision.exe
            $mainExe = $allExeFiles | Where-Object { 
              $_ -like "*MarkVision.exe" -and $_ -notlike "*nsis*" 
            } | Select-Object -First 1
            
            if ($mainExe) {
              $exePath = $mainExe
              Write-Host "找到可执行文件(通过名称): $exePath"
            } else {
              # 退而选择任何其他exe文件
              $exePath = $allExeFiles | Select-Object -First 1
              Write-Host "找到可执行文件(替代): $exePath"
            }
          }
          
          if (-not $exePath) {
            Write-Host "错误: 无法找到 $appName.exe 文件"
            exit 1
          }
          
          # 创建便携式目录
          New-Item -Path $portableDir -ItemType Directory -Force
          
          # 复制主程序和所需文件
          Copy-Item -Path $exePath -Destination "$portableDir\$appName.exe"
          
          # 需要的DLL和资源文件(如果有的话)会由Tauri自动打包到exe中，无需额外复制
          
          # 创建配置和数据目录
          New-Item -Path "$portableDir\config" -ItemType Directory -Force
          New-Item -Path "$portableDir\data" -ItemType Directory -Force
          
          # 创建简单的说明文件
          @"
          $appName 便携版 v$version
          
          使用说明:
          1. 解压后直接运行 $appName.exe
          2. 程序会在当前目录的config文件夹中保存配置
          3. 用户数据将存储在data文件夹中
          
          此便携版无需安装，可直接在U盘等移动设备上运行。
          "@ | Out-File -FilePath "$portableDir\readme.txt" -Encoding utf8
          
          # 压缩便携版文件夹
          Compress-Archive -Path "$portableDir\*" -DestinationPath "$appName-portable-v$version.zip" -Force
          
          # 输出创建的文件路径供后续步骤使用
          echo "便携版已创建: $appName-portable-v$version.zip"
          echo "PORTABLE_ZIP=$appName-portable-v$version.zip" >> $env:GITHUB_ENV

      # 上传便携版到Release
      - name: 上传便携版到Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.NEW_VERSION }}
          files: |
            ${{ env.PORTABLE_ZIP }}
          token: ${{ secrets.GITHUB_TOKEN }}
          
      # 检查构建产物目录
      - name: 检查构建产物目录
        if: always()
        run: |
          $targetDir = "src-tauri/target"
          echo "--- Target Directory Structure ---"
          if (Test-Path $targetDir) {
            Get-ChildItem -Path $targetDir -Recurse -Depth 2 | Select-Object FullName
          } else {
            echo "Directory not found: $targetDir"
          }
          
          $releaseDir = "src-tauri/target/release"
          echo "`n--- Release Directory Structure ---"
          if (Test-Path $releaseDir) {
            Get-ChildItem -Path $releaseDir -Recurse | Select-Object FullName
          } else {
            echo "Directory not found: $releaseDir"
          }
          
          echo "`n--- Portable Package ---"
          Get-ChildItem -Path "*.zip" | Select-Object FullName
        shell: pwsh
          
      # 提交版本号更新 (添加 [skip ci])
      - name: 提交版本号更新
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json src-tauri/tauri.conf.json
          git commit -m "自动更新版本号到 v${{ steps.version.outputs.NEW_VERSION }} [skip ci]"
          git push
        shell: pwsh